TUTORIAL 1: Introduction to Rosewood

	The Rosewood Gaming Engine is a javascript library for creating 2d browser-based games.
	With its simple, but powerful API and fast runtime, Rosewood makes game design quick and easy.

	To get started, create a folder for your new game and put a copy of rosewood.js inside of it.
	Next, create another folder, called "sprites" inside this folder. 
	Now, open up your favorite text editor and create a new file called "play.html" inside the game folder.
	Edit play.html so that it looks like this:

		<html>
			<head>
				<title>My first Rosewood Game</title>
				<script type="text/javascript" src="rosewood.js"></script>
				<script type="text/javascript" src="game.js"></script>
			</head>
			<body>
				<script type="text/javascript">
					startGame();
				</script>
			</body>
		</html>

	We've created a simple html page with links to rosewood.js and a non-existant game.js in the head
	and a call to the non-existant function startGame() in the body.

	Create the file game.js with your text editor and edit it so it looks like this:

		var startGame = function() {
			rw.init(500,500)
			.start();
		}

	Now that we've fixed the problem of the non-existant file and function, open play.html in your web browser.
	You should now be staring at a blank 500 by 500 pixel box.
	Inside this box is the Rosewood game board, which is currently doing nothing at 20 Frames Per Second (the default framerate).
	Before we start adding things, let's take a quick look at the startGame() function.

	The first thing that is called in the function is rw.init(500,500) (all Rosewood functions start with rw)
		The init(x,y) function creates a Game Board that is x pixels wide and y pixels high.
		All of the action in our game will be contained inside this board, which is a div element with the id "board".
		By default the board div is appended to the document's body
		A third, optional argument, the id of the target element can be specified in the init function to append the board to a specific element.
		Example: rw.init(500, 500, "main") would create a 500 by 500 board appended to an element with the id "main".
		The init() function also sets up a number of things behind the scenes, allowing Rosewood to begin tracking keyboard and mouse inputs.
		The init() function, like many Rosewood functions, returns the rw object, allowing us to chain the next function.

	The rw.start() function is simple, if the engine is not running, it starts it, at the current framerate.
		Until specified otherwise, Rosewood runs at a framerate of 20 FPS (frames per second). 
		The framerate can be changed using the rw.setFPS(fps) function.
		Example:

			rw.init(500,500)
			.setFPS(40)
			.start();

			Would create a 500 by 500 pixel board running at a framerate of 40 frames per second.
			(As you can see, the setFPS() function is chainable like the init() and start() functions)

	Let's move on and start adding things to our game board.
	The most important objects in Rosewood are entities, or ents.
	Ents can have sprites, which are displayed on the game board 
	And most importantly, during each frame the engine updates the location and behavior of every active ent.

	To create our first ent, we first need to add graphics for it.
	Place the folder titled "hero" inside our sprites folder in the main game folder.
	There should be a number of sprites in the hero folder including "u.png", "d.png", "l.png" and "r.png".
	Now, in game.js above the startGame() function, add the following:

		var hero = function(name) {
			this.base = new rw.ent(name, 'hero', 'd', 'png', 32, 32);
			this.update = function() {
			}
		}

	This function will be used to create our first ent.
	As you can see, the function has one argument (name) and returns an object with 2 properties, base and update.
	The base property is of utmost importance. 
	ALL ENTITIES MUST HAVE A base PROPERTY WITH AN rw.ent() AS ITS VALUE.
	The rw.ent() Object that is assigned to the base property is what Rosewood uses to track and display an entity.
	The base property (through rw.ent()) also contains many function methods needed for changing an ent's behavior.
	rw.ent() takes a number of arguments, as follows:
		name, THIS MUST BE UNIQUE.
		spriteFolder, folder that holds this ent's sprites ('hero' folder in this case)
		defaultSprite, default sprite to show ('d' in this case)
		spriteExt, the filetype extension of the ent's sprites ('png' in this case, as in 'd.png' etc)
		width, the ent's width in pixels (32 in this case)
		height, the ent's height in pixels (32 in this case)
	The second property defined in the hero() function is update, a blank function.
	Once per frame, Rosewood calls the update() function of every active ent.
	This allows us to control the movement and behavior of every ent through time within the game.
	We'll leave this function blank for now, but will come back to it shortly.

	Now that we've set up a bare-bones ent and added graphics for it, lets add it to the game.
	Edit the startGame() function in game.js, so that it looks like this:

		rw.init(500,500)
		.newEnt(new hero('hero'))
			.base.display('d', 234, 234, 234)
			.end()
		.start();

	We've added 3 lines here. 
	The first: .newEnt(new hero('hero')) creates a new ent and returns it so we can do things with it.
	The second line: .base.display('d', 234, 234, 234) accesses the ent's base property and calls the function display(sprite, x, y, z)
	display() accepts 4 arguments, the sprite to display and the x, y, z coordinates of where it should be located on the game board.
	The third line: .end() is a call to another method in the base property, which ends the sub-chain and returns us back to the rw chain.
	Reload play.html in your browser and you should see our hero standing in the middle of the board, doing nothing at 20 FPS.
	It's slightly more exciting having something do nothing than nothing do nothing, but it's still nowhere near a game yet.

	We're going to revisit the blank update() function inside the hero() function.
	Edit it so it like this:

		this.update = function() {
			if (rw.key('ua')) {
				this.base.move(0, -1);
			}
			if (rw.key('da')) {
				this.base.move(0, 1);
			}
			if (rw.key('la')) {
				this.base.move(-1, 0);
			}
			if (rw.key('ra')) {
				this.base.move(1, 0);
			}
		}

	Save the file, reload play.html and try pressing the arrow keys. Movement!
	A quick look at our new update() function will reveal a few things to us.
	There are 4 if statements inside the function.
	Each if calls the rw.key() function to check if a certain key is down.
	In this case, the 4 ifs refer to the 4 arrow keys ('ua' = up arrow, etc).
	If the key is currently being pressed, the function will return true.
	This, in turn calls the entity's base.move(x, y) function, moving the entity.
	As you can see by pressing two arrow keys at once, the base.move(x, y) function is additive,
	meaning that each move does not overwrite the previous move.

	That's it for Tutorial 1, we've created an incredibly basic almost-game and learned a bit about how Rosewood works.
	In th next tutorial, we will begin to improve upon our hero and create more entities.

	game.js after tutorial 1:

		var hero = function(name) {
			this.base = new rw.ent(name, 'hero', 'd', 'png', 32, 32);
			this.update = function {
				if (rw.key('ua')) {
					this.base.move(0, -1);
				}
				if (rw.key('da')) {
					this.base.move(0, 1);
				}
				if (rw.key('la')) {
					this.base.move(-1, 0);
				}
				if (rw.key('ra')) {
					this.base.move(1, 0);
				}
			}
		}

		var startGame = function() {
			rw.init(500, 500)
			.newEnt(new hero('hero'))
				.base.display('d', 234, 234, 234)
				.end()
			.start();
		}
